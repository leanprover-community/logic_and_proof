
<!DOCTYPE html>

<html>
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. Introduction &#8212; Logic and Proof 3.18.4 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Propositional Logic" href="propositional_logic.html" />
    <link rel="prev" title="Logic and Proof" href="index.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="introduction">
<span id="id1"></span><h1><span class="section-number">1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">&#182;</a></h1>
<div class="section" id="mathematical-proof">
<h2><span class="section-number">1.1. </span>Mathematical Proof<a class="headerlink" href="#mathematical-proof" title="Permalink to this headline">&#182;</a></h2>
<p>Although there is written evidence of mathematical activity in Egypt as early as 3000 BC, many scholars locate the birth of mathematics proper in ancient Greece around the sixth century BC, when deductive proof was first introduced. Aristotle credited Thales of Miletus with recognizing the importance of not just what we know but how we know it, and finding grounds for knowledge in the deductive method. Around 300 BC, Euclid codified a deductive approach to geometry in his treatise, the <em>Elements</em>. Through the centuries, Euclid&#8217;s axiomatic style was held as a paradigm of rigorous argumentation, not just in mathematics, but in philosophy and the sciences as well.</p>
<p>Here is an example of an ordinary proof, in contemporary mathematical language. It establishes a fact that was known to the Pythagoreans.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> <span class="math notranslate nohighlight">\(\sqrt 2\)</span> is irrational, which is to say, it cannot be expressed as a fraction <span class="math notranslate nohighlight">\(a / b\)</span>, where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are integers.</p>
<p><strong>Proof.</strong> Suppose <span class="math notranslate nohighlight">\(\sqrt 2 = a / b\)</span> for some pair of integers <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>. By removing any common factors, we can assume <span class="math notranslate nohighlight">\(a / b\)</span> is in lowest terms, so that <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have no factor in common. Then we have <span class="math notranslate nohighlight">\(a = \sqrt 2 b\)</span>, and squaring both sides, we have <span class="math notranslate nohighlight">\(a^2 = 2 b^2\)</span>.</p>
<p>The last equation implies that <span class="math notranslate nohighlight">\(a^2\)</span> is even, and since the square of an odd number is odd, <span class="math notranslate nohighlight">\(a\)</span> itself must be even as well. We therefore have <span class="math notranslate nohighlight">\(a = 2c\)</span> for some integer <span class="math notranslate nohighlight">\(c\)</span>. Substituting this into the equation <span class="math notranslate nohighlight">\(a^2 = 2 b^2\)</span>, we have <span class="math notranslate nohighlight">\(4 c^2 = 2 b^2\)</span>, and hence <span class="math notranslate nohighlight">\(2 c^2 = b^2\)</span>. This means that <span class="math notranslate nohighlight">\(b^2\)</span> is even, and so <span class="math notranslate nohighlight">\(b\)</span> is even as well.</p>
<p>The fact that <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are both even contradicts the fact that <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have no common factor. So the original assumption that <span class="math notranslate nohighlight">\(\sqrt 2 = a / b\)</span> is false.</p>
<hr class="docutils" />
<p>In the next example, we focus on the natural numbers,</p>
<div class="math notranslate nohighlight">
\[\mathbb{N} = \{ 0, 1, 2, \ldots \}.\]</div>
<p>A natural number <span class="math notranslate nohighlight">\(n\)</span> greater than or equal to 2 is said to be <em>composite</em> if it can be written as a product <span class="math notranslate nohighlight">\(n = m \cdot k\)</span> where neither <span class="math notranslate nohighlight">\(m\)</span> nor <span class="math notranslate nohighlight">\(k\)</span> is equal to <span class="math notranslate nohighlight">\(1\)</span>, and <em>prime</em> otherwise. Notice that if <span class="math notranslate nohighlight">\(n = m \cdot k\)</span> witnesses the fact that <span class="math notranslate nohighlight">\(n\)</span> is composite, then <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(k\)</span> are both smaller than <span class="math notranslate nohighlight">\(n\)</span>. Notice also that, by convention, 0 and 1 are considered neither prime nor composite.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Every natural number greater than or equal to 2 can be written as a product of primes.</p>
<p><strong>Proof.</strong> We proceed by induction on <span class="math notranslate nohighlight">\(n\)</span>. Let <span class="math notranslate nohighlight">\(n\)</span> be any natural number greater than 2. If <span class="math notranslate nohighlight">\(n\)</span> is prime, we are done; we can consider <span class="math notranslate nohighlight">\(n\)</span> itself as a product with one factor. Otherwise, <span class="math notranslate nohighlight">\(n\)</span> is composite, and we can write <span class="math notranslate nohighlight">\(n = m \cdot k\)</span> where <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(k\)</span> are smaller than <span class="math notranslate nohighlight">\(n\)</span> and greater than 1. By the inductive hypothesis, each of <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(k\)</span> can be written as a product of primes, say
<span class="math notranslate nohighlight">\(m = p_1 \cdot p_2 \cdot \ldots \cdot p_u\)</span> and <span class="math notranslate nohighlight">\(k = q_1 \cdot q_2 \cdot \ldots \cdot q_v\)</span>. But then we have</p>
<div class="math notranslate nohighlight">
\[n = m \cdot k = p_1 \cdot p_2 \cdot \ldots \cdot p_u \cdot q_1 \cdot
q_2 \cdot \ldots \cdot q_v,\]</div>
<p>a product of primes, as required.</p>
<hr class="docutils" />
<p>Later, we will see that more is true: every natural number greater than 2 can be written as a product of primes in a unique way, a fact known as the <em>fundamental theorem of arithmetic</em>.</p>
<p>The first goal of this course is to teach you to write clear, readable mathematical proofs. We will do this by considering a number of examples, but also by taking a reflective point of view: we will carefully study the components of mathematical language and the structure of mathematical proofs, in order to gain a better understanding of how they work.</p>
</div>
<div class="section" id="symbolic-logic">
<h2><span class="section-number">1.2. </span>Symbolic Logic<a class="headerlink" href="#symbolic-logic" title="Permalink to this headline">&#182;</a></h2>
<p>Toward understanding how proofs work, it will be helpful to study a subject known as &#8220;symbolic logic,&#8221; which provides an idealized model of mathematical language and proof. In the <em>Prior Analytics</em>, the ancient Greek philosopher Aristotle set out to analyze patterns of reasoning, and developed the theory of the <em>syllogism</em>. Here is one instance of a syllogism:</p>
<hr class="docutils" />
<p>Every man is an animal.</p>
<p>Every animal is mortal.</p>
<p>Therefore every man is mortal.</p>
<hr class="docutils" />
<p>Aristotle observed that the correctness of this inference has nothing to do with the truth or falsity of the individual statements, but, rather, the general pattern:</p>
<hr class="docutils" />
<p>Every A is B.</p>
<p>Every B is C.</p>
<p>Therefore every A is C.</p>
<hr class="docutils" />
<p>We can substitute various properties for A, B, and C; try substituting the properties of being a fish, being a unicorn, being a swimming creature, being a mythical creature, etc. The various statements that result may come out true or false, but all the instantiations will have the following crucial feature: if the two hypotheses come out true, then the conclusion comes out true as well. We express this by saying that the inference is <em>valid</em>.</p>
<p>Although the patterns of language addressed by Aristotle&#8217;s theory of reasoning are limited, we have him to thank for a crucial insight: we can classify valid patterns of inference by their logical form, while abstracting away specific content. It is this fundamental observation that underlies the entire field of symbolic logic.</p>
<p>In the seventeenth century, Leibniz proposed the design of a <em>characteristica universalis</em>, a universal symbolic language in which one would express any assertion in a precise way, and a <em>calculus ratiocinator</em>, a &#8220;calculus of thought&#8221; which would express the precise rules of reasoning. Leibniz himself took some steps to develop such a language and calculus, but much greater strides were made in the nineteenth century, through the work of Boole, Frege, Peirce, Schroeder, and others. Early in the twentieth century, these efforts blossomed into the field of mathematical logic.</p>
<p>If you consider the examples of proofs in the last section, you will notice that some terms and rules of inference are specific to the subject matter at hand, having to do with numbers and the properties of being prime, composite, even, odd, and so on. But there are other terms and rules of inference that are not domain specific, such as those related to the words &#8220;every,&#8221; &#8220;some,&#8221; &#8220;and,&#8221; and &#8220;if &#8230; then.&#8221; The goal of symbolic logic is to identify these core elements of reasoning and argumentation and explain how they work, as well as to explain how more domain-specific notions are introduced and used.</p>
<p>To that end, we will introduce symbols for key logical notions, including the following:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A \to B\)</span>, &#8220;<span class="math notranslate nohighlight">\(\mbox{if $A$ then $B$}\)</span>&#8221;</p></li>
<li><p><span class="math notranslate nohighlight">\(A \wedge B\)</span>, &#8220;<span class="math notranslate nohighlight">\(\mbox{$A$ and $B$}\)</span>&#8221;</p></li>
<li><p><span class="math notranslate nohighlight">\(A \vee B\)</span>, &#8220;<span class="math notranslate nohighlight">\(\mbox{$A$ or $B$}\)</span>&#8221;</p></li>
<li><p><span class="math notranslate nohighlight">\(\neg A\)</span>, &#8220;<span class="math notranslate nohighlight">\(\mbox{not $A$}\)</span>&#8221;</p></li>
<li><p><span class="math notranslate nohighlight">\(\forall x \; A\)</span>, &#8220;<span class="math notranslate nohighlight">\(\mbox{for every $x$, $A$}\)</span>&#8221;</p></li>
<li><p><span class="math notranslate nohighlight">\(\exists x \; A\)</span>, &#8220;<span class="math notranslate nohighlight">\(\mbox{for some $x$, $A$}\)</span>&#8221;</p></li>
</ul>
<p>We will then provide a formal proof system that will let us establish, deductively, that certain entailments between such statements are valid.</p>
<p>The proof system we will use is a version of <em>natural deduction</em>, a type of proof system introduced by Gerhard Gentzen in the 1930s to model informal styles of argument. In this system, the fundamental unit of judgment is the assertion that a statement, <span class="math notranslate nohighlight">\(A\)</span>, follows from a finite set of hypotheses, <span class="math notranslate nohighlight">\(\Gamma\)</span>. This is written as <span class="math notranslate nohighlight">\(\Gamma \vdash A\)</span>. If <span class="math notranslate nohighlight">\(\Gamma\)</span> and <span class="math notranslate nohighlight">\(\Delta\)</span> are two finite sets of hypotheses, we will write <span class="math notranslate nohighlight">\(\Gamma, \Delta\)</span> for the <em>union</em> of these two sets, that is, the set consisting of all the hypotheses in each. With these conventions, the rule for the conjunction
symbol can be expressed as follows:</p>
<img src="_static/introduction.1.png"><p>This should be interpreted as saying: assuming <span class="math notranslate nohighlight">\(A\)</span> follows from the hypotheses <span class="math notranslate nohighlight">\(\Gamma\)</span>, and <span class="math notranslate nohighlight">\(B\)</span> follows from the hypotheses <span class="math notranslate nohighlight">\(\Delta\)</span>, <span class="math notranslate nohighlight">\(A \wedge B\)</span> follows from the hypotheses in both <span class="math notranslate nohighlight">\(\Gamma\)</span> and <span class="math notranslate nohighlight">\(\Delta\)</span>.</p>
<p>We will see that one can write such proofs more compactly leaving the hypotheses implicit, so that the rule above is expressed as follows:</p>
<img src="_static/introduction.2.png"><p>In this format, a snippet of the first proof in the previous section might be rendered as follows:</p>
<img src="_static/introduction.3.png"><p>The complexity of such proofs can quickly grow out of hand, and complete proofs of even elementary mathematical facts can become quite long. Such systems are not designed for writing serious mathematics. Rather, they provide idealized models of mathematical inference, and insofar as they capture something of the structure of an informal proof, they enable us to study the properties of mathematical reasoning.</p>
<p>The second goal of this course is to help you understand natural deduction, as an example of a formal deductive system.</p>
</div>
<div class="section" id="interactive-theorem-proving">
<h2><span class="section-number">1.3. </span>Interactive Theorem Proving<a class="headerlink" href="#interactive-theorem-proving" title="Permalink to this headline">&#182;</a></h2>
<p>Early work in mathematical logic aimed to show that ordinary mathematical arguments could be modeled in symbolic calculi, at least in principle. As noted above, complexity issues limit the range of what can be accomplished in practice; even elementary mathematical arguments require long derivations that are hard to write and hard to read, and do little to promote understanding of the underlying mathematics.</p>
<p>Since the end of the twentieth century, however, the advent of computational proof assistants has begun to make complete formalization feasible. Working interactively with theorem proving software, users can construct formal derivations of complex theorems that can be stored and checked by computer. Automated methods can be used to fill in small gaps by hand, verify long calculations axiomatically, or fill in long chains of inferences deterministically. The reach of automation is currently fairly limited, however. The strategy used in interactive theorem proving is to ask users to provide just enough information for the system to be able to construct and check a formal derivation. This typically involves writing proofs in a sort of &#8220;programming language&#8221; that is designed with that purpose in mind. For example, here is a short proof in the <em>Lean</em> theorem prover:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://live.lean-lang.org/#code=section%0Avariable%20(P%20Q%20%3A%20Prop)%0A%0Atheorem%20my_theorem%20%3A%20P%20%E2%88%A7%20Q%20%E2%86%92%20Q%20%E2%88%A7%20P%20%3A%3D%20by%0A%20%20rintro%20h%20%3A%20P%20%E2%88%A7%20Q%0A%20%20apply%20And.intro%0A%20%20.%20exact%20And.right%20h%0A%20%20.%20exact%20And.left%20h%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">my_theorem</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">&#8743;</span> <span class="n">Q</span> <span class="bp">&#8594;</span> <span class="n">Q</span> <span class="bp">&#8743;</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rintro</span> <span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">&#8743;</span> <span class="n">Q</span>
  <span class="n">apply</span> <span class="n">And.intro</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">And.right</span> <span class="n">h</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">And.left</span> <span class="n">h</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>If you are reading the present text in online form, you will find a button above the formal &#8220;proof script&#8221; that says &#8220;try it!&#8221; Pressing the button opens the proof in an editor window and runs a version of Lean inside your browser to process the proof, turn it into an axiomatic derivation, and verify its correctness. You can experiment by varying the text in the editor; any errors will be noted in the window to the right.</p>
<p>Proofs in Lean can access a library of prior mathematical results, all verified down to axiomatic foundations. A goal of the field of interactive theorem proving is to reach the point where any contemporary theorem can be verified in this way. For example, here is a formal proof that the square root of two is irrational, following the model of the informal proof presented above:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://live.lean-lang.org/#code=import%20Mathlib.Data.Nat.Prime.Basic%0Aopen%20Nat%0Aopen%20Prime%0A%0Asection%0A%0Atheorem%20sqrt_two_irrational%20%7Ba%20b%20%3A%20%E2%84%95%7D%20(co%20%3A%20gcd%20a%20b%20%3D%201)%20%3A%0A%20%20%20%20a%5E2%20%E2%89%A0%202%20*%20b%5E2%20%3A%3D%20by%0A%20%20rintro%20h%20%3A%20a%5E2%20%3D%202%20*%20b%5E2%0A%20%20have%20%3A%202%20%E2%88%A3%20a%5E2%20%3A%3D%20by%0A%20%20%20%20simp%20%5Bh%5D%0A%20%20have%20%3A%202%20%E2%88%A3%20a%20%3A%3D%0A%20%20%20%20dvd_of_dvd_pow%20prime_two%20this%0A%20%20apply%20Exists.elim%20this%0A%20%20rintro%20c%20aeq%0A%20%20have%20%3A%202%20*%20(2%20*%20c%5E2)%20%3D%202%20*%20b%5E2%20%3A%3D%20by%0A%20%20%20%20simp%20%5BEq.symm%20h%2C%20aeq%5D%0A%20%20%20%20simp%20%5Bpow_succ'%20_%2C%20mul_comm%2C%20mul_assoc%2C%20mul_left_comm%5D%0A%20%20have%20%3A%202%20*%20c%5E2%20%3D%20b%5E2%20%3A%3D%20by%0A%20%20%20%20apply%20mul_left_cancel%E2%82%80%20_%20this%0A%20%20%20%20decide%0A%20%20have%20%3A%202%20%E2%88%A3%20b%5E2%20%3A%3D%20by%0A%20%20%20%20simp%20%5BEq.symm%20this%5D%0A%20%20have%20%3A%202%20%E2%88%A3%20b%20%3A%3D%20by%0A%20%20%20%20exact%20dvd_of_dvd_pow%20prime_two%20this%0A%20%20have%20%3A%202%20%E2%88%A3%20gcd%20a%20b%20%3A%3D%20by%0A%20%20%20%20apply%20dvd_gcd%0A%20%20%20%20.%20assumption%0A%20%20%20%20.%20assumption%0A%20%20have%20_%20%3A%202%20%E2%88%A3%20(1%20%3A%20%E2%84%95)%20%3A%3D%20by%0A%20%20%20%20simp%20%5Bco%5D%20at%20*%0A%20%20contradiction%0A%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">Mathlib.Data.Nat.Prime.Basic</span>
<span class="kn">open</span> <span class="n">Nat</span>
<span class="kn">open</span> <span class="n">Prime</span>

<span class="kn">section</span>

<span class="kd">theorem</span> <span class="n">sqrt_two_irrational</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">}</span> <span class="o">(</span><span class="n">co</span> <span class="o">:</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">a</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">&#8800;</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rintro</span> <span class="n">h</span> <span class="o">:</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&#8739;</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&#8739;</span> <span class="n">a</span> <span class="o">:=</span>
    <span class="n">dvd_of_dvd_pow</span> <span class="n">prime_two</span> <span class="n">this</span>
  <span class="n">apply</span> <span class="n">Exists.elim</span> <span class="n">this</span>
  <span class="n">rintro</span> <span class="n">c</span> <span class="n">aeq</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">Eq.symm</span> <span class="n">h</span><span class="o">,</span> <span class="n">aeq</span><span class="o">]</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">pow_succ&#39;</span> <span class="n">_</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">]</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">c</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">apply</span> <span class="n">mul_left_cancel&#8320;</span> <span class="n">_</span> <span class="n">this</span>
    <span class="n">decide</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&#8739;</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">Eq.symm</span> <span class="n">this</span><span class="o">]</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&#8739;</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">exact</span> <span class="n">dvd_of_dvd_pow</span> <span class="n">prime_two</span> <span class="n">this</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&#8739;</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">apply</span> <span class="n">dvd_gcd</span>
    <span class="bp">.</span> <span class="n">assumption</span>
    <span class="bp">.</span> <span class="n">assumption</span>
  <span class="k">have</span> <span class="n">_</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&#8739;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">co</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
  <span class="n">contradiction</span>

<span class="kd">end</span>
</pre></div>
</div>
</div><p>The third goal of this course is to teach you to write elementary proofs in Lean. The facts that we will ask you to prove in Lean will be more elementary than the informal proofs we will ask you to write, but our intent is that formal proofs will model and clarify the informal proof strategies we will teach you.</p>
</div>
<div class="section" id="the-semantic-point-of-view">
<h2><span class="section-number">1.4. </span>The Semantic Point of View<a class="headerlink" href="#the-semantic-point-of-view" title="Permalink to this headline">&#182;</a></h2>
<p>As we have presented the subject here, the goal of symbolic logic is to specify a language and rules of inference that enable us to get at the truth in a reliable way. The idea is that the symbols we choose denote objects and concepts that have a fixed meaning, and the rules of inference we adopt enable us to draw true conclusions from true hypotheses.</p>
<p>One can adopt another view of logic, however, as a system where some symbols have a fixed meaning, such as the symbols for &#8220;and,&#8221; &#8220;or,&#8221; and &#8220;not,&#8221; and others have a meaning that is taken to vary. For example, the expression <span class="math notranslate nohighlight">\(P \wedge (Q \vee R)\)</span>, read &#8220;<span class="math notranslate nohighlight">\(P\)</span> and either <span class="math notranslate nohighlight">\(Q\)</span> or <span class="math notranslate nohighlight">\(R\)</span>,&#8221; may be true or false <em>depending on the basic assertions that</em> <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, <em>and</em> <span class="math notranslate nohighlight">\(R\)</span> <em>stand for</em>. More precisely, the truth of the compound expression depends only on whether the component symbols denote expressions that are true or false. For example, if <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> stand for &#8220;seven is prime,&#8221; &#8220;seven is even,&#8221; and &#8220;seven is odd,&#8221; respectively, then the expression is true. If we replace &#8220;seven&#8221; by &#8220;six,&#8221; the statement is false. More generally, the expression comes out true whenever <span class="math notranslate nohighlight">\(P\)</span> is true and at least one of <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(R\)</span> is true, and false otherwise.</p>
<p>From this perspective, logic is not so much a language for asserting truth, but a language for describing possible states of affairs. In other words, logic provides a specification language, with expressions that can be true or false depending on how we interpret the symbols that are allowed to vary. For example, if we fix the meaning of the basic predicates, the statement &#8220;there is a red block between two blue blocks&#8221; may be true or false of a given &#8220;world&#8221; of blocks, and we can take the expression to describe the set of worlds in which it is true. Such a view of logic is important in computer science, where we use logical expressions to select entries from a database matching certain criteria, to specify properties of hardware and software systems, or to assert constraints that we would like a constraint solver to satisfy.</p>
<p>There are important connections between the syntactic / deductive point of view on the one hand, and the semantic / model-theoretic point of view on the other. We will explore some of these along the way. For example, we will see that it is possible to view the &#8220;valid&#8221; assertions as those that are true under all possible interpretations of the non-fixed symbols, and the &#8220;valid&#8221; inferences as those that maintain truth in all possible states and affairs. From this point of view, a deductive system should only allow us to derive valid assertions and entailments, a property known as <em>soundness</em>. If a deductive system is strong enough to allow us to verify <em>all</em> valid assertions and entailments, it is said to be <em>complete</em>.</p>
<p>The fourth goal of this course is to convey the semantic view of logic, and to lead you to understand how logical expressions can be used to specify states of affairs.</p>
</div>
<div class="section" id="goals-summarized">
<h2><span class="section-number">1.5. </span>Goals Summarized<a class="headerlink" href="#goals-summarized" title="Permalink to this headline">&#182;</a></h2>
<p>To summarize, these are the goals of this course:</p>
<ul class="simple">
<li><p>You should learn to write clear, &#8220;literate,&#8221; mathematical proofs.</p></li>
<li><p>You should become comfortable with symbolic logic and the formal modeling of deductive proof.</p></li>
<li><p>You should learn how to use an interactive proof assistant.</p></li>
<li><p>You should understand how to use logic as a precise language for making claims about systems of objects and the relationships between them, and specifying certain states of affairs.</p></li>
</ul>
<p>Let us take a moment to consider the relationship between some of these goals. It is important not to confuse the first three. We are dealing with three kinds of mathematical language: ordinary mathematical language, the symbolic representations of mathematical logic, and computational implementations in interactive proof assistants. These are very different things!</p>
<p>Symbolic logic is not meant to replace ordinary mathematical language, and you should not use symbols like <span class="math notranslate nohighlight">\(\wedge\)</span> and <span class="math notranslate nohighlight">\(\vee\)</span> in ordinary mathematical proofs any more than you would use them in place of the words &#8220;and&#8221; and &#8220;or&#8221; in letters home to your parents. Natural languages provide nuances of expression that can convey levels of meaning and understanding that go beyond pattern matching to verify correctness. At the same time, modeling mathematical language with symbolic expressions provides a level of precision that makes it possible to turn mathematical language itself into an object of study. Each has its place, and we hope to get you to appreciate the value of each without confusing the two.</p>
<p>The proof languages used by interactive theorem provers lie somewhere between the two extremes. On the one hand, they have to be specified with enough precision for a computer to process them and act appropriately; on the other hand, they aim to capture some of the higher-level nuances and features of informal language in a way that enables us to write more complex arguments and proofs. Rooted in symbolic logic and designed with ordinary mathematical language in mind, they aim to bridge the gap between the two.</p>
<p>This book also aims to show you how mathematics is built up from fundamental concepts. Logic provides the rules of the game, and then we work our way up from properties of sets, relations, functions, and the natural numbers to elementary number theory, combinatorics, and properties of the real numbers. The last chapter rounds out the story with a discussion of axiomatic foundations.</p>
</div>
<div class="section" id="about-this-textbook">
<h2><span class="section-number">1.6. </span>About this Textbook<a class="headerlink" href="#about-this-textbook" title="Permalink to this headline">&#182;</a></h2>
<p>Both this online textbook and the <em>Lean</em> theorem prover are ongoing projects.
The original <code class="docutils literal notranslate"><span class="pre">lean3</span></code> version of this textbook
is available <a class="reference external" href="https://leanprover.github.io/logic_and_proof_lean3/index.html">here</a>.
This version introduces <code class="docutils literal notranslate"><span class="pre">lean4</span></code> instead.</p>
<p>You can learn more about Lean from its <a class="reference external" href="http://leanlang.org">project page</a>,
the Lean <a class="reference external" href="http://leanprover-community.github.io/">community pages</a>, and the online textbook,
<a class="reference external" href="http://leanprover.github.io/theorem_proving_in_lean4/">Theorem Proving in Lean</a>.</p>
<p>The original textbook was written by Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
This was adapted to <code class="docutils literal notranslate"><span class="pre">lean4</span></code> by Joseph Hua.
We are grateful for feedback and corrections from a number of people,
including Bruno Cuconato, William DeMeo, Tobias Grosser, Lyle Kopnicky,
Alexandre Rademaker, Matt Rice, and Jason Siefken.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#mathematical-proof">1.1. Mathematical Proof</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symbolic-logic">1.2. Symbolic Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interactive-theorem-proving">1.3. Interactive Theorem Proving</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-semantic-point-of-view">1.4. The Semantic Point of View</a></li>
<li class="toctree-l2"><a class="reference internal" href="#goals-summarized">1.5. Goals Summarized</a></li>
<li class="toctree-l2"><a class="reference internal" href="#about-this-textbook">1.6. About this Textbook</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">15. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions_in_lean.html">16. Functions in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction_in_lean.html">18. The Natural Numbers and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorics.html">20. Combinatorics</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_real_numbers.html">21. The Real Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_infinite.html">22. The Infinite</a></li>
<li class="toctree-l1"><a class="reference internal" href="axiomatic_foundations.html">23. Axiomatic Foundations</a></li>
<li class="toctree-l1"><a class="reference internal" href="nd_quickref.html">24. Appendix: Natural Deduction Rules</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Joseph Hua, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/introduction.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>